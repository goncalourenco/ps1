"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const int64_buffer_1 = require("int64-buffer");
const pkcs11 = tslib_1.__importStar(require("pkcs11js"));
const fs = tslib_1.__importStar(require("fs"));
const core = tslib_1.__importStar(require("./core"));
const mech_enum_1 = require("./mech_enum");
tslib_1.__exportStar(require("./mech_enum"), exports);
var MechanismFlag;
(function (MechanismFlag) {
    MechanismFlag[MechanismFlag["HW"] = pkcs11.CKF_HW] = "HW";
    MechanismFlag[MechanismFlag["ENCRYPT"] = pkcs11.CKF_ENCRYPT] = "ENCRYPT";
    MechanismFlag[MechanismFlag["DECRYPT"] = pkcs11.CKF_DECRYPT] = "DECRYPT";
    MechanismFlag[MechanismFlag["DIGEST"] = pkcs11.CKF_DIGEST] = "DIGEST";
    MechanismFlag[MechanismFlag["SIGN"] = pkcs11.CKF_SIGN] = "SIGN";
    MechanismFlag[MechanismFlag["SIGN_RECOVER"] = pkcs11.CKF_SIGN_RECOVER] = "SIGN_RECOVER";
    MechanismFlag[MechanismFlag["VERIFY"] = pkcs11.CKF_VERIFY] = "VERIFY";
    MechanismFlag[MechanismFlag["VERIFY_RECOVER"] = pkcs11.CKF_VERIFY_RECOVER] = "VERIFY_RECOVER";
    MechanismFlag[MechanismFlag["GENERATE"] = pkcs11.CKF_GENERATE] = "GENERATE";
    MechanismFlag[MechanismFlag["GENERATE_KEY_PAIR"] = pkcs11.CKF_GENERATE_KEY_PAIR] = "GENERATE_KEY_PAIR";
    MechanismFlag[MechanismFlag["WRAP"] = pkcs11.CKF_WRAP] = "WRAP";
    MechanismFlag[MechanismFlag["UNWRAP"] = pkcs11.CKF_UNWRAP] = "UNWRAP";
    MechanismFlag[MechanismFlag["DERIVE"] = pkcs11.CKF_DERIVE] = "DERIVE";
})(MechanismFlag = exports.MechanismFlag || (exports.MechanismFlag = {}));
class Mechanism extends core.HandleObject {
    get name() {
        return mech_enum_1.MechanismEnum[this.type] || "unknown";
    }
    static create(algorithm) {
        let res;
        let alg;
        if (core.isString(algorithm)) {
            alg = { name: algorithm, params: null };
        }
        else if (core.isNumber(algorithm)) {
            alg = { name: mech_enum_1.MechanismEnum[algorithm], params: null };
        }
        else {
            alg = algorithm;
        }
        const hAlg = mech_enum_1.MechanismEnum[alg.name.toUpperCase()];
        if (core.isEmpty(hAlg)) {
            throw new TypeError(`Unknown mechanism name '${alg.name}'`);
        }
        let params = null;
        if (alg.params) {
            if (alg.params.toCKI) {
                params = alg.params.toCKI();
            }
            else {
                params = alg.params;
            }
        }
        res = {
            mechanism: hAlg,
            parameter: params,
        };
        return res;
    }
    static vendor(name, value) {
        const mechs = mech_enum_1.MechanismEnum;
        if (core.isEmpty(value)) {
            const file = fs.readFileSync(name);
            const vendor = JSON.parse(file.toString());
            for (const i in vendor) {
                const newName = i;
                const v = vendor[i];
                mechs[newName] = v;
                mechs[v] = newName;
            }
        }
        else {
            const newName = name;
            mechs[newName] = value;
            mechs[value] = newName;
        }
    }
    constructor(type, handle, slotHandle, lib) {
        super(handle, lib);
        this.type = type;
        this.slotHandle = slotHandle;
        this.getInfo();
    }
    getInfo() {
        const info = this.lib.C_GetMechanismInfo(this.slotHandle, this.type);
        this.minKeySize = info.minKeySize;
        this.maxKeySize = info.maxKeySize;
        this.flags = info.flags;
    }
}
exports.Mechanism = Mechanism;
class MechanismCollection extends core.Collection {
    constructor(items, slotHandle, lib, classType = Mechanism) {
        super(items, lib, classType);
        this.slotHandle = slotHandle;
    }
    items(index) {
        const type = this.items_[index];
        const handle = new int64_buffer_1.Int64LE(type).toBuffer();
        return new Mechanism(type, handle, this.slotHandle, this.lib);
    }
}
exports.MechanismCollection = MechanismCollection;
