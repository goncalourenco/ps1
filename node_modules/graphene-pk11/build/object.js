"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const pkcs11 = tslib_1.__importStar(require("pkcs11js"));
const core = tslib_1.__importStar(require("./core"));
const template_1 = require("./template");
var ObjectClass;
(function (ObjectClass) {
    ObjectClass[ObjectClass["DATA"] = pkcs11.CKO_DATA] = "DATA";
    ObjectClass[ObjectClass["CERTIFICATE"] = pkcs11.CKO_CERTIFICATE] = "CERTIFICATE";
    ObjectClass[ObjectClass["PUBLIC_KEY"] = pkcs11.CKO_PUBLIC_KEY] = "PUBLIC_KEY";
    ObjectClass[ObjectClass["PRIVATE_KEY"] = pkcs11.CKO_PRIVATE_KEY] = "PRIVATE_KEY";
    ObjectClass[ObjectClass["SECRET_KEY"] = pkcs11.CKO_SECRET_KEY] = "SECRET_KEY";
    ObjectClass[ObjectClass["HW_FEATURE"] = pkcs11.CKO_HW_FEATURE] = "HW_FEATURE";
    ObjectClass[ObjectClass["DOMAIN_PARAMETERS"] = pkcs11.CKO_DOMAIN_PARAMETERS] = "DOMAIN_PARAMETERS";
    ObjectClass[ObjectClass["MECHANISM"] = pkcs11.CKO_MECHANISM] = "MECHANISM";
    ObjectClass[ObjectClass["OTP_KEY"] = pkcs11.CKO_OTP_KEY] = "OTP_KEY";
})(ObjectClass = exports.ObjectClass || (exports.ObjectClass = {}));
class SessionObject extends core.HandleObject {
    get size() {
        return this.lib.C_GetObjectSize(this.session.handle, this.handle);
    }
    constructor(handle, session, lib) {
        if (handle instanceof SessionObject) {
            const obj = handle;
            super(obj.handle, obj.lib);
            this.session = obj.session;
        }
        else {
            super(handle, lib);
            this.session = session;
        }
    }
    copy(template) {
        const tmpl = template_1.Template.toPkcs11(template);
        const hObject = this.lib.C_CopyObject(this.session.handle, this.handle, tmpl);
        return new SessionObject(hObject, this.session, this.lib);
    }
    destroy() {
        this.lib.C_DestroyObject(this.session.handle, this.handle);
    }
    getAttribute(attrs) {
        let template;
        if (typeof attrs === "string") {
            template = {};
            template[attrs] = null;
        }
        else {
            template = attrs;
        }
        let tmpl = template_1.Template.toPkcs11(template);
        tmpl = this.lib.C_GetAttributeValue(this.session.handle, this.handle, tmpl);
        if (typeof attrs === "string") {
            return template_1.Template.fromPkcs11(tmpl)[attrs];
        }
        return template_1.Template.fromPkcs11(tmpl);
    }
    setAttribute(attrs, value) {
        if (core.isString(attrs)) {
            const tmp = {};
            tmp[attrs] = value;
            attrs = tmp;
        }
        const tmpl = template_1.Template.toPkcs11(attrs);
        this.lib.C_SetAttributeValue(this.session.handle, this.handle, tmpl);
    }
    get(name) {
        const tmpl = {};
        tmpl[name] = null;
        return this.getAttribute(tmpl)[name];
    }
    set(name, value) {
        const tmpl = {};
        tmpl[name] = value;
        this.setAttribute(tmpl);
    }
    get class() {
        return this.get("class");
    }
    set class(v) {
        this.set("class", v);
    }
    toType() {
        const c = this.class;
        switch (c) {
            case ObjectClass.DATA:
                return new objects.Data(this);
            case ObjectClass.DOMAIN_PARAMETERS:
                return new objects.DomainParameters(this);
            case ObjectClass.CERTIFICATE:
                const cert = new objects.Certificate(this);
                const t = cert.type;
                switch (t) {
                    case objects.CertificateType.X_509:
                        return new objects.X509Certificate(this);
                    case objects.CertificateType.WTLS:
                        return new objects.WtlsCertificate(this);
                    case objects.CertificateType.X_509_ATTR_CERT:
                        return new objects.AttributeCertificate(this);
                    default:
                        throw new Error(`Unknown certificate (CKC_?) type '${t}'`);
                }
            case ObjectClass.PRIVATE_KEY:
                return new objects.PrivateKey(this);
            case ObjectClass.PUBLIC_KEY:
                return new objects.PublicKey(this);
            case ObjectClass.SECRET_KEY:
                return new objects.SecretKey(this);
            case ObjectClass.HW_FEATURE:
            case ObjectClass.OTP_KEY:
                throw new Error(`Type converter for ${ObjectClass[c]} is not implemented`);
            default:
                throw new Error(`Unknown session object (CKO_?) type '${c}'`);
        }
    }
}
exports.SessionObject = SessionObject;
class SessionObjectCollection extends core.Collection {
    constructor(items, session, lib, classType = SessionObject) {
        super(items, lib, classType);
        this.session = session;
    }
    items(index) {
        return new SessionObject(this.items_[index], this.session, this.lib);
    }
}
exports.SessionObjectCollection = SessionObjectCollection;
const objects = tslib_1.__importStar(require("./objects"));
tslib_1.__exportStar(require("./objects"), exports);
tslib_1.__exportStar(require("./keys"), exports);
