"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core = require("webcrypto-core");
const WebCryptoError = core.CryptoError;
const graphene = require("graphene-pk11");
const cert_storage_1 = require("./cert_storage");
const key_storage_1 = require("./key_storage");
const subtle_1 = require("./subtle");
const utils = require("./utils");
global.btoa = (data) => Buffer.from(data, "binary").toString("base64");
global.atob = (data) => Buffer.from(data, "base64").toString("binary");
class Crypto {
    constructor(props) {
        const mod = graphene.Module.load(props.library, props.name || props.library);
        this.name = props.name;
        try {
            if (props.libraryParameters) {
                mod.initialize({
                    libraryParameters: props.libraryParameters,
                });
            }
            else {
                mod.initialize();
            }
        }
        catch (e) {
            if (!/CKR_CRYPTOKI_ALREADY_INITIALIZED/.test(e.message)) {
                throw e;
            }
        }
        this.initialized = true;
        const slotIndex = props.slot || 0;
        const slots = mod.getSlots(true);
        if (!(0 <= slotIndex && slotIndex < slots.length)) {
            throw new WebCryptoError(`Slot by index ${props.slot} is not found`);
        }
        this.slot = slots.items(slotIndex);
        this.token = this.slot.getToken();
        this.isLoginRequired = !!(this.token.flags & graphene.TokenFlag.LOGIN_REQUIRED);
        this.isLoggedIn = !this.isLoginRequired;
        this.isReadWrite = !!props.readWrite;
        this.open(props.readWrite);
        if (props.pin && this.isLoginRequired) {
            this.login(props.pin);
        }
        for (const i in props.vendors) {
            graphene.Mechanism.vendor(props.vendors[i]);
        }
        this.subtle = new subtle_1.SubtleCrypto(this);
        this.keyStorage = new key_storage_1.KeyStorage(this);
        this.certStorage = new cert_storage_1.CertificateStorage(this);
    }
    open(rw) {
        let flags = graphene.SessionFlag.SERIAL_SESSION;
        if (rw) {
            flags |= graphene.SessionFlag.RW_SESSION;
        }
        this.session = this.slot.open(flags);
        this.info = utils.getProviderInfo(this.slot);
        if (this.name) {
            this.info.name = this.name;
        }
    }
    reset() {
        if (this.isLoggedIn && this.isLoginRequired) {
            this.logout();
        }
        this.session.close();
        this.open(this.isReadWrite);
    }
    login(pin) {
        if (!this.isLoginRequired) {
            return;
        }
        try {
            this.session.login(pin);
        }
        catch (error) {
            if (!/CKR_USER_ALREADY_LOGGED_IN\:256/.test(error.message)) {
                throw error;
            }
        }
        this.isLoggedIn = true;
    }
    logout() {
        if (!this.isLoginRequired) {
            return;
        }
        try {
            this.session.logout();
        }
        catch (error) {
            if (!/CKR_USER_NOT_LOGGED_IN\:257/.test(error.message)) {
                throw error;
            }
        }
        this.isLoggedIn = false;
    }
    getRandomValues(array) {
        if (array.byteLength > 65536) {
            throw new core.CryptoError(`Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length (${array.byteLength}) exceeds the number of bytes of entropy available via this API (65536).`);
        }
        const bytes = new Uint8Array(this.session.generateRandom(array.byteLength));
        array.set(bytes);
        return array;
    }
    close() {
        if (this.initialized) {
            this.session.logout();
            this.session.close();
            this.module.finalize();
            this.module.close();
        }
    }
}
exports.Crypto = Crypto;
