"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphene_pk11_1 = require("graphene-pk11");
const core = require("webcrypto-core");
const webcrypto_core_1 = require("webcrypto-core");
const cert_1 = require("./cert");
const TEMPLATES = [
    { class: graphene_pk11_1.ObjectClass.CERTIFICATE, certType: graphene_pk11_1.CertificateType.X_509, token: true },
    { class: graphene_pk11_1.ObjectClass.DATA, token: true, label: "X509 Request" },
];
class CertificateStorage {
    constructor(crypto) {
        this.crypto = crypto;
    }
    indexOf(item) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (item instanceof cert_1.CryptoCertificate && item.p11Object.token) {
                return cert_1.CryptoCertificate.getID(item.p11Object);
            }
            return null;
        });
    }
    keys() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keys = [];
            TEMPLATES.forEach((template) => {
                this.crypto.session.find(template, (obj) => {
                    const item = obj.toType();
                    const id = cert_1.CryptoCertificate.getID(item);
                    keys.push(id);
                });
            });
            return keys;
        });
    }
    clear() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const objects = [];
            TEMPLATES.forEach((template) => {
                this.crypto.session.find(template, (obj) => {
                    objects.push(obj);
                });
            });
            objects.forEach((obj) => {
                obj.destroy();
            });
        });
    }
    hasItem(item) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sessionObject = this.getItemById(item.id);
            return !!sessionObject;
        });
    }
    getItem(index, algorithm, usages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const storageObject = this.getItemById(index);
            if (storageObject instanceof graphene_pk11_1.X509Certificate) {
                const x509Object = storageObject.toType();
                const x509 = new cert_1.X509Certificate(this.crypto);
                x509.p11Object = x509Object;
                yield x509.exportKey(algorithm, usages);
                return x509;
            }
            else if (storageObject instanceof graphene_pk11_1.Data) {
                const x509Object = storageObject.toType();
                const x509request = new cert_1.X509CertificateRequest(this.crypto);
                x509request.p11Object = x509Object;
                yield x509request.exportKey(algorithm, usages);
                return x509request;
            }
            else {
                return null;
            }
        });
    }
    removeItem(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sessionObject = this.getItemById(key);
            if (sessionObject) {
                sessionObject.destroy();
            }
        });
    }
    setItem(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!(data instanceof cert_1.CryptoCertificate)) {
                throw new Error("Incoming data is not PKCS#11 CryptoCertificate");
            }
            if (!data.p11Object.token) {
                const obj = this.crypto.session.copy(data.p11Object, {
                    token: true,
                });
                return cert_1.CryptoCertificate.getID(obj.toType());
            }
            else {
                return data.id;
            }
        });
    }
    exportCert(format, cert) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (format) {
                case "pem": {
                    throw Error("PEM format is not implemented");
                }
                case "raw": {
                    return cert.exportCert();
                }
                default:
                    throw new Error(`Unsupported format in use ${format}`);
            }
        });
    }
    importCert(format, data, algorithm, usages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let rawData;
            let rawType = null;
            switch (format) {
                case "pem":
                    if (typeof data !== "string") {
                        throw new TypeError("data: Is not type string");
                    }
                    if (webcrypto_core_1.PemConverter.isCertificate(data)) {
                        rawType = "x509";
                    }
                    else if (webcrypto_core_1.PemConverter.isCertificateRequest(data)) {
                        rawType = "request";
                    }
                    else {
                        throw new core.OperationError("data: Is not correct PEM data. Must be Certificate or Certificate Request");
                    }
                    rawData = core.PemConverter.toArrayBuffer(data);
                    break;
                case "raw":
                    if (!core.BufferSourceConverter.isBufferSource(data)) {
                        throw new TypeError("data: Is not type ArrayBuffer or ArrayBufferView");
                    }
                    rawData = core.BufferSourceConverter.toArrayBuffer(data);
                    break;
                default:
                    throw new TypeError("format: Is invalid value. Must be 'raw', 'pem'");
            }
            switch (rawType) {
                case "x509": {
                    const x509 = new cert_1.X509Certificate(this.crypto);
                    yield x509.importCert(Buffer.from(rawData), algorithm, usages);
                    return x509;
                }
                case "request": {
                    const request = new cert_1.X509CertificateRequest(this.crypto);
                    yield request.importCert(Buffer.from(rawData), algorithm, usages);
                    return request;
                }
                default: {
                    try {
                        const x509 = new cert_1.X509Certificate(this.crypto);
                        yield x509.importCert(Buffer.from(rawData), algorithm, usages);
                        return x509;
                    }
                    catch (_a) {
                    }
                    try {
                        const request = new cert_1.X509CertificateRequest(this.crypto);
                        yield request.importCert(Buffer.from(rawData), algorithm, usages);
                        return request;
                    }
                    catch (_b) {
                    }
                    throw new core.OperationError("Cannot parse Certificate or Certificate Request from incoming ASN1");
                }
            }
        });
    }
    getItemById(id) {
        let object = null;
        TEMPLATES.forEach((template) => {
            this.crypto.session.find(template, (obj) => {
                const item = obj.toType();
                if (id === cert_1.CryptoCertificate.getID(item)) {
                    object = item;
                    return false;
                }
            });
        });
        return object;
    }
}
exports.CertificateStorage = CertificateStorage;
