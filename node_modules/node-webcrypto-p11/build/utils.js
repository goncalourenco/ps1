"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const graphene_pk11_1 = require("graphene-pk11");
const pvtsutils_1 = require("pvtsutils");
const webcrypto_core_1 = require("webcrypto-core");
const const_1 = require("./const");
function GUID(session) {
    return crypto.randomBytes(20);
}
exports.GUID = GUID;
function b64UrlDecode(b64url) {
    return Buffer.from(pvtsutils_1.Convert.FromBase64Url(b64url));
}
exports.b64UrlDecode = b64UrlDecode;
function prepareData(data) {
    return Buffer.from(webcrypto_core_1.BufferSourceConverter.toArrayBuffer(data));
}
exports.prepareData = prepareData;
function isHashedAlgorithm(data) {
    return data instanceof Object
        && "name" in data
        && "hash" in data;
}
exports.isHashedAlgorithm = isHashedAlgorithm;
function isCryptoKeyPair(data) {
    return data && data.privateKey && data.publicKey;
}
exports.isCryptoKeyPair = isCryptoKeyPair;
function prepareAlgorithm(algorithm) {
    if (typeof algorithm === "string") {
        return {
            name: algorithm,
        };
    }
    if (isHashedAlgorithm(algorithm)) {
        const preparedAlgorithm = Object.assign({}, algorithm);
        preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);
        return preparedAlgorithm;
    }
    return Object.assign({}, algorithm);
}
exports.prepareAlgorithm = prepareAlgorithm;
function digest(algorithm, data) {
    const hash = crypto.createHash(algorithm.replace("-", ""));
    hash.update(prepareData(Buffer.from(webcrypto_core_1.BufferSourceConverter.toArrayBuffer(data))));
    return hash.digest();
}
exports.digest = digest;
function calculateProviderID(slot) {
    const str = slot.manufacturerID + slot.slotDescription + slot.getToken().serialNumber + slot.handle.toString("hex");
    return digest(const_1.ID_DIGEST, Buffer.from(str)).toString("hex");
}
function getProviderInfo(slot) {
    const slots = slot.module.getSlots(true);
    let index = -1;
    for (let i = 0; i < slots.length; i++) {
        if (slots.items(i).handle.equals(slot.handle)) {
            index = i;
            break;
        }
    }
    const token = slot.getToken();
    const provider = {
        id: calculateProviderID(slot),
        slot: index,
        name: token.label,
        reader: slot.slotDescription,
        serialNumber: slot.getToken().serialNumber,
        algorithms: [],
        isRemovable: !!(slot.flags & graphene_pk11_1.SlotFlag.REMOVABLE_DEVICE),
        isHardware: !!(slot.flags & graphene_pk11_1.SlotFlag.HW_SLOT),
    };
    const algorithms = slot.getMechanisms();
    for (let i = 0; i < algorithms.length; i++) {
        const algorithm = algorithms.items(i);
        let algName = "";
        switch (algorithm.name) {
            case "SHA_1":
                algName = "SHA-1";
                break;
            case "SHA256":
                algName = "SHA-256";
                break;
            case "SHA384":
                algName = "SHA-384";
                break;
            case "SHA512":
                algName = "SHA-512";
                break;
            case "RSA_PKCS":
            case "SHA1_RSA_PKCS":
            case "SHA256_RSA_PKCS":
            case "SHA384_RSA_PKCS":
            case "SHA512_RSA_PKCS":
                algName = "RSASSA-PKCS1-v1_5";
                break;
            case "SHA1_RSA_PSS":
            case "SHA256_RSA_PSS":
            case "SHA384_RSA_PSS":
            case "SHA512_RSA_PSS":
                algName = "RSA-PSS";
                break;
            case "SHA1_RSA_PKCS_PSS":
            case "SHA256_RSA_PKCS_PSS":
            case "SHA384_RSA_PKCS_PSS":
            case "SHA512_RSA_PKCS_PSS":
                algName = "RSA-PSS";
                break;
            case "RSA_PKCS_OAEP":
                algName = "RSA-OAEP";
                break;
            case "ECDSA":
            case "ECDSA_SHA1":
            case "ECDSA_SHA256":
            case "ECDSA_SHA384":
            case "ECDSA_SHA512":
                algName = "ECDSA";
                break;
            case "ECDH1_DERIVE":
                algName = "ECDH";
                break;
            case "AES_CBC_PAD":
                algName = "AES-CBC";
                break;
            case "AES_ECB":
            case "AES_ECB_PAD":
                algName = "AES-ECB";
                break;
            case "AES_GCM_PAD":
                algName = "AES-GCM";
                break;
            case "AES_KEY_WRAP_PAD":
                algName = "AES-KW";
                break;
            default:
        }
        if (algName && !provider.algorithms.some((alg) => alg === algName)) {
            provider.algorithms.push(algName);
        }
    }
    return provider;
}
exports.getProviderInfo = getProviderInfo;
