"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Asn1Js = require("asn1js");
const graphene_pk11_1 = require("graphene-pk11");
const pvtsutils_1 = require("pvtsutils");
const p11_object_1 = require("./p11_object");
const utils = require("./utils");
const PkiJs = require("pkijs");
PkiJs.CertificationRequest.prototype.getPublicKey = PkiJs.Certificate.prototype.getPublicKey;
const OID = {
    "2.5.4.3": {
        short: "CN",
        long: "CommonName",
    },
    "2.5.4.6": {
        short: "C",
        long: "Country",
    },
    "2.5.4.5": {
        long: "DeviceSerialNumber",
    },
    "0.9.2342.19200300.100.1.25": {
        short: "DC",
        long: "DomainComponent",
    },
    "1.2.840.113549.1.9.1": {
        short: "E",
        long: "EMail",
    },
    "2.5.4.42": {
        short: "G",
        long: "GivenName",
    },
    "2.5.4.43": {
        short: "I",
        long: "Initials",
    },
    "2.5.4.7": {
        short: "L",
        long: "Locality",
    },
    "2.5.4.10": {
        short: "O",
        long: "Organization",
    },
    "2.5.4.11": {
        short: "OU",
        long: "OrganizationUnit",
    },
    "2.5.4.8": {
        short: "ST",
        long: "State",
    },
    "2.5.4.9": {
        short: "Street",
        long: "StreetAddress",
    },
    "2.5.4.4": {
        short: "SN",
        long: "SurName",
    },
    "2.5.4.12": {
        short: "T",
        long: "Title",
    },
    "1.2.840.113549.1.9.8": {
        long: "UnstructuredAddress",
    },
    "1.2.840.113549.1.9.2": {
        long: "UnstructuredName",
    },
};
function nameToString(name, splitter = ",") {
    const res = [];
    name.typesAndValues.forEach((typeValue) => {
        const type = typeValue.type;
        const oidValue = OID[type.toString()];
        const oidName = oidValue && oidValue.short ? oidValue.short : type.toString();
        res.push(oidName + "=" + typeValue.value.valueBlock.value);
    });
    return res.join(splitter + " ");
}
exports.nameToString = nameToString;
class CryptoCertificate extends p11_object_1.Pkcs11Object {
    static getID(p11Object) {
        let type;
        let id;
        if (p11Object instanceof graphene_pk11_1.Data) {
            type = "request";
            id = p11Object.objectId;
        }
        else if (p11Object instanceof graphene_pk11_1.X509Certificate) {
            type = "x509";
            id = p11Object.id;
        }
        if (!type) {
            throw new Error("Unsupported PKCS#11 object");
        }
        return `${type}-${p11Object.handle.toString("hex")}-${id.toString("hex")}`;
    }
    get id() {
        return CryptoCertificate.getID(this.p11Object);
    }
    constructor(crypto) {
        super();
        this.crypto = crypto;
    }
}
exports.CryptoCertificate = CryptoCertificate;
class X509Certificate extends CryptoCertificate {
    constructor() {
        super(...arguments);
        this.type = "x509";
    }
    get serialNumber() {
        return Buffer.from(this.getData().serialNumber.valueBlock._valueHex).toString("hex");
    }
    get notBefore() {
        return this.getData().notBefore.value;
    }
    get notAfter() {
        return this.getData().notAfter.value;
    }
    get issuerName() {
        return nameToString(this.getData().issuer);
    }
    get subjectName() {
        return nameToString(this.getData().subject);
    }
    get value() {
        return new Uint8Array(this.p11Object.value).buffer;
    }
    importCert(data, algorithm, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const array = new Uint8Array(data);
            this.parse(array.buffer);
            const publicKeyInfoSchema = this.schema.subjectPublicKeyInfo.toSchema();
            const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
            this.publicKey = (yield this.crypto.subtle.importKey("spki", publicKeyInfoBuffer, algorithm, true, keyUsages));
            const hashSPKI = this.publicKey.p11Object.id;
            const label = this.getName();
            this.p11Object = this.crypto.session.create({
                id: hashSPKI,
                label,
                class: graphene_pk11_1.ObjectClass.CERTIFICATE,
                certType: graphene_pk11_1.CertificateType.X_509,
                serial: Buffer.from(this.schema.serialNumber.toBER(false)),
                subject: Buffer.from(this.schema.subject.toSchema(true).toBER(false)),
                issuer: Buffer.from(this.schema.issuer.toSchema(true).toBER(false)),
                token: false,
                private: false,
                value: Buffer.from(data),
            }).toType();
        });
    }
    exportCert() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.value;
        });
    }
    toJSON() {
        return {
            publicKey: this.publicKey.toJSON(),
            notBefore: this.notBefore,
            notAfter: this.notAfter,
            subjectName: this.subjectName,
            issuerName: this.issuerName,
            serialNumber: this.serialNumber,
            type: this.type,
            value: pvtsutils_1.Convert.ToBase64Url(this.value),
        };
    }
    exportKey(algorithm, usages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.publicKey) {
                const publicKeyID = this.id.replace(/\w+-\w+-/i, "");
                const keyIndexes = yield this.crypto.keyStorage.keys();
                for (const keyIndex of keyIndexes) {
                    const parts = keyIndex.split("-");
                    if (parts[0] === "public" && parts[2] === publicKeyID) {
                        this.publicKey = yield this.crypto.keyStorage.getItem(keyIndex, algorithm, usages);
                        break;
                    }
                }
                if (!this.publicKey) {
                    let params;
                    if (algorithm) {
                        params = {
                            algorithm: {
                                algorithm: utils.prepareAlgorithm(algorithm),
                                usages,
                            },
                        };
                    }
                    PkiJs.setEngine("pkcs11", this.crypto, new PkiJs.CryptoEngine({ name: "pkcs11", crypto: this.crypto, subtle: this.crypto.subtle }));
                    this.publicKey = yield this.getData().getPublicKey(params);
                }
            }
            return this.publicKey;
        });
    }
    parse(data) {
        const asn1 = Asn1Js.fromBER(data);
        this.schema = new PkiJs.Certificate({ schema: asn1.result });
    }
    getData() {
        if (!this.schema) {
            this.parse(this.value);
        }
        return this.schema;
    }
    getName() {
        const cert = this.getData();
        for (const typeAndValue of cert.subject.typesAndValues) {
            if (typeAndValue.type === "2.5.4.3") {
                return typeAndValue.value.valueBlock.value;
            }
        }
        return this.subjectName;
    }
}
exports.X509Certificate = X509Certificate;
class X509CertificateRequest extends CryptoCertificate {
    constructor() {
        super(...arguments);
        this.type = "request";
    }
    get subjectName() {
        return nameToString(this.getData().subject);
    }
    get value() {
        return new Uint8Array(this.p11Object.value).buffer;
    }
    importCert(data, algorithm, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const array = new Uint8Array(data).buffer;
            this.parse(array);
            const publicKeyInfoSchema = this.schema.subjectPublicKeyInfo.toSchema();
            const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
            this.publicKey = (yield this.crypto.subtle.importKey("spki", publicKeyInfoBuffer, algorithm, true, keyUsages));
            const hashSPKI = this.publicKey.p11Object.id;
            this.p11Object = this.crypto.session.create({
                objectId: hashSPKI,
                application: "webcrypto-p11",
                class: graphene_pk11_1.ObjectClass.DATA,
                label: "X509 Request",
                token: false,
                private: false,
                value: Buffer.from(data),
            }).toType();
        });
    }
    exportCert() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.value;
        });
    }
    toJSON() {
        return {
            publicKey: this.publicKey.toJSON(),
            subjectName: this.subjectName,
            type: this.type,
            value: pvtsutils_1.Convert.ToBase64Url(this.value),
        };
    }
    exportKey(algorithm, usages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.publicKey) {
                const publicKeyID = this.id.replace(/\w+-\w+-/i, "");
                const keyIndexes = yield this.crypto.keyStorage.keys();
                for (const keyIndex of keyIndexes) {
                    const parts = keyIndex.split("-");
                    if (parts[0] === "public" && parts[2] === publicKeyID) {
                        this.publicKey = yield this.crypto.keyStorage.getItem(keyIndex, algorithm, usages);
                        break;
                    }
                }
                if (!this.publicKey) {
                    let params;
                    if (algorithm) {
                        params = {
                            algorithm: {
                                algorithm: utils.prepareAlgorithm(algorithm),
                                usages,
                            },
                        };
                    }
                    PkiJs.setEngine("pkcs11", this.crypto, new PkiJs.CryptoEngine({ name: "pkcs11", crypto: this.crypto, subtle: this.crypto.subtle }));
                    this.publicKey = yield this.getData().getPublicKey(params);
                }
            }
            return this.publicKey;
        });
    }
    parse(data) {
        const asn1 = Asn1Js.fromBER(data);
        this.schema = new PkiJs.CertificationRequest({ schema: asn1.result });
    }
    getData() {
        if (!this.schema) {
            this.parse(this.value);
        }
        return this.schema;
    }
}
exports.X509CertificateRequest = X509CertificateRequest;
