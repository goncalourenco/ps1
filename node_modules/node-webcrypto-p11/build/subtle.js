"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core = require("webcrypto-core");
const const_1 = require("./const");
const key_1 = require("./key");
const mechs_1 = require("./mechs");
const utils = require("./utils");
class SubtleCrypto extends core.SubtleCrypto {
    constructor(crypto) {
        super();
        this.crypto = crypto;
        this.providers.set(new mechs_1.AesCbcProvider(this.crypto));
        this.providers.set(new mechs_1.AesEcbProvider(this.crypto));
        this.providers.set(new mechs_1.AesGcmProvider(this.crypto));
        this.providers.set(new mechs_1.RsaSsaProvider(this.crypto));
        this.providers.set(new mechs_1.RsaPssProvider(this.crypto));
        this.providers.set(new mechs_1.RsaOaepProvider(this.crypto));
        this.providers.set(new mechs_1.EcdsaProvider(this.crypto));
        this.providers.set(new mechs_1.EcdhProvider(this.crypto));
        this.providers.set(new mechs_1.Sha1Provider(this.crypto));
        this.providers.set(new mechs_1.Sha256Provider(this.crypto));
        this.providers.set(new mechs_1.Sha384Provider(this.crypto));
        this.providers.set(new mechs_1.Sha512Provider(this.crypto));
        this.providers.set(new mechs_1.HmacProvider(this.crypto));
    }
    generateKey(algorithm, extractable, keyUsages) {
        const _super = Object.create(null, {
            generateKey: { get: () => super.generateKey }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keys = yield _super.generateKey.call(this, algorithm, extractable, keyUsages);
            if (utils.isCryptoKeyPair(keys)) {
                const publicKey = keys.publicKey;
                const privateKey = keys.privateKey;
                const raw = yield this.exportKey("raw", publicKey);
                const digest = utils.digest(const_1.ID_DIGEST, raw);
                publicKey.key.id = digest;
                publicKey.id = key_1.CryptoKey.getID(publicKey.key);
                privateKey.key.id = digest;
                privateKey.id = key_1.CryptoKey.getID(privateKey.key);
            }
            return keys;
        });
    }
    importKey(format, keyData, algorithm, extractable, keyUsages) {
        const _super = Object.create(null, {
            importKey: { get: () => super.importKey }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield _super.importKey.call(this, format, keyData, algorithm, extractable, keyUsages);
            if (key.type === "public" && extractable) {
                const publicKey = key;
                const raw = yield this.exportKey("raw", publicKey);
                const digest = utils.digest(const_1.ID_DIGEST, raw);
                publicKey.key.id = digest;
                publicKey.id = key_1.CryptoKey.getID(publicKey.key);
            }
            return key;
        });
    }
}
exports.SubtleCrypto = SubtleCrypto;
