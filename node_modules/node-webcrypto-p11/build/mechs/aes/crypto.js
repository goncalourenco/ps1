"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphene_pk11_1 = require("graphene-pk11");
const graphene = require("graphene-pk11");
const pvtsutils_1 = require("pvtsutils");
const core = require("webcrypto-core");
const key_1 = require("../../key");
const utils = require("../../utils");
class AesCrypto {
    static generateKey(session, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const template = this.createTemplate(session, algorithm, extractable, keyUsages);
                template.valueLen = algorithm.length >> 3;
                session.generateKey(graphene_pk11_1.KeyGenMechanism.AES, template, (err, aesKey) => {
                    try {
                        if (err) {
                            reject(new core.CryptoError(`Aes: Can not generate new key\n${err.message}`));
                        }
                        else {
                            resolve(new key_1.CryptoKey(aesKey, algorithm));
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        });
    }
    static exportKey(session, format, key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const template = key.key.getAttribute({ value: null, valueLen: null });
            switch (format.toLowerCase()) {
                case "jwk":
                    const aes = /AES-(\w+)/.exec(key.algorithm.name)[1];
                    const jwk = {
                        kty: "oct",
                        k: pvtsutils_1.Convert.ToBase64Url(template.value),
                        alg: `A${template.valueLen * 8}${aes}`,
                        ext: true,
                        key_ops: key.usages,
                    };
                    return jwk;
                case "raw":
                    return new Uint8Array(template.value).buffer;
                    break;
                default:
                    throw new core.OperationError("format: Must be 'jwk' or 'raw'");
            }
        });
    }
    static importKey(session, format, keyData, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let value;
            switch (format.toLowerCase()) {
                case "jwk":
                    if (!("k" in keyData)) {
                        throw new core.OperationError("jwk.k: Cannot get required property");
                    }
                    keyData = pvtsutils_1.Convert.FromBase64Url(keyData.k);
                case "raw":
                    value = keyData;
                    switch (value.byteLength) {
                        case 16:
                        case 24:
                        case 32:
                            break;
                        default:
                            throw new core.OperationError("keyData: Is wrong key length");
                    }
                    break;
                default:
                    throw new core.OperationError("format: Must be 'jwk' or 'raw'");
            }
            const aesAlg = {
                name: algorithm.name,
                length: value.byteLength * 8,
            };
            const template = this.createTemplate(session, aesAlg, extractable, keyUsages);
            template.value = Buffer.from(value);
            const sessionObject = session.create(template);
            const key = new key_1.CryptoKey(sessionObject.toType(), aesAlg);
            return key;
        });
    }
    static encrypt(session, padding, algorithm, key, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (padding) {
                const blockLength = 16;
                const mod = blockLength - (data.byteLength % blockLength);
                const pad = Buffer.alloc(mod);
                pad.fill(mod);
                data = Buffer.concat([Buffer.from(data), pad]);
            }
            return new Promise((resolve, reject) => {
                const enc = Buffer.alloc(this.getOutputBufferSize(key.algorithm, true, data.byteLength));
                const mechanism = this.wc2pk11(session, algorithm);
                session.createCipher(mechanism, key.key)
                    .once(Buffer.from(data), enc, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(new Uint8Array(data2).buffer);
                    }
                });
            });
        });
    }
    static decrypt(session, padding, algorithm, key, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const dec = yield new Promise((resolve, reject) => {
                const buf = Buffer.alloc(this.getOutputBufferSize(key.algorithm, false, data.length));
                const mechanism = this.wc2pk11(session, algorithm);
                session.createDecipher(mechanism, key.key)
                    .once(Buffer.from(data), buf, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2);
                    }
                });
            });
            if (padding) {
                const paddingLength = dec[dec.length - 1];
                const res = new Uint8Array(dec.slice(0, dec.length - paddingLength));
                return res.buffer;
            }
            else {
                return new Uint8Array(dec).buffer;
            }
        });
    }
    static createTemplate(session, alg, extractable, keyUsages) {
        const id = utils.GUID(session);
        return {
            token: !!process.env.WEBCRYPTO_PKCS11_TOKEN,
            sensitive: !!process.env.WEBCRYPTO_PKCS11_SENSITIVE,
            class: graphene_pk11_1.ObjectClass.SECRET_KEY,
            keyType: graphene_pk11_1.KeyType.AES,
            label: `AES-${alg.length}`,
            id,
            extractable,
            derive: false,
            sign: keyUsages.indexOf("sign") !== -1,
            verify: keyUsages.indexOf("verify") !== -1,
            encrypt: keyUsages.indexOf("encrypt") !== -1 || keyUsages.indexOf("wrapKey") !== -1,
            decrypt: keyUsages.indexOf("decrypt") !== -1 || keyUsages.indexOf("unwrapKey") !== -1,
            wrap: keyUsages.indexOf("wrapKey") !== -1,
            unwrap: keyUsages.indexOf("unwrapKey") !== -1,
        };
    }
    static isAesGCM(algorithm) {
        return algorithm.name.toUpperCase() === "AES-GCM";
    }
    static isAesCBC(algorithm) {
        return algorithm.name.toUpperCase() === "AES-CBC";
    }
    static isAesECB(algorithm) {
        return algorithm.name.toUpperCase() === "AES-ECB";
    }
    static wc2pk11(session, algorithm) {
        if (this.isAesGCM(algorithm)) {
            const aad = algorithm.additionalData ? utils.prepareData(algorithm.additionalData) : undefined;
            let AesGcmParamsClass = graphene.AesGcmParams;
            if (session &&
                session.slot.module.cryptokiVersion.major >= 2 &&
                session.slot.module.cryptokiVersion.minor >= 40) {
                AesGcmParamsClass = graphene.AesGcm240Params;
            }
            const params = new AesGcmParamsClass(utils.prepareData(algorithm.iv), aad, algorithm.tagLength || 128);
            return { name: "AES_GCM", params };
        }
        else if (this.isAesCBC(algorithm)) {
            return { name: "AES_CBC_PAD", params: utils.prepareData(algorithm.iv) };
        }
        else if (this.isAesECB(algorithm)) {
            return { name: "AES_ECB", params: null };
        }
        else {
            throw new core.OperationError("Unrecognized algorithm name");
        }
    }
    static getOutputBufferSize(keyAlg, enc, dataSize) {
        const len = keyAlg.length >> 3;
        if (enc) {
            return (Math.ceil(dataSize / len) * len) + len;
        }
        else {
            return dataSize;
        }
    }
}
exports.AesCrypto = AesCrypto;
