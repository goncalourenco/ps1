"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class EcUtils {
    static getData(data) {
        let octet = false;
        for (let i = 0; i < data.length; i++) {
            if (data[i] === 4) {
                if (octet) {
                    return data.slice(i);
                }
                else {
                    octet = true;
                }
            }
        }
        throw new Error("Wrong data");
    }
    static decodePoint(data, curve, prepare = false) {
        if (curve.name === "curve25519") {
            return {
                x: data,
            };
        }
        if (prepare) {
            data = this.getData(data);
        }
        if ((data.length === 0) || (data[0] !== 4)) {
            throw new Error("Only uncompressed point format supported");
        }
        const n = (data.length - 1) / 2;
        if (n !== (Math.ceil(curve.size / 8))) {
            throw new Error("Point does not match field size");
        }
        const xb = data.slice(1, 1 + n);
        const yb = data.slice(n + 1, n + 1 + n);
        return { x: xb, y: yb };
    }
    static encodePoint(point, curve) {
        const n = Math.ceil(curve.size / 8);
        const xb = this.padZeroes(point.x, n);
        const yb = this.padZeroes(point.y, n);
        if ((xb.length > n) || (yb.length > n)) {
            throw new Error("Point coordinates do not match field size");
        }
        const b = Buffer.concat([Buffer.from([4]), xb, yb]);
        const octet = Buffer.concat([Buffer.from([4]), this.encodeAsn1Length(b.length), b]);
        return octet;
    }
    static trimZeroes(b) {
        let i = 0;
        while ((i < b.length - 1) && (b[i] === 0)) {
            i++;
        }
        if (i === 0) {
            return b;
        }
        return b.slice(i, b.length);
    }
    static padZeroes(b, size) {
        const pad = Buffer.alloc(size - b.length);
        pad.fill(0, 0, pad.length);
        return Buffer.concat([pad, b]);
    }
    static encodeAsn1Length(length) {
        const enc = [];
        if (length !== (length & 0x7F)) {
            let code = length.toString(16);
            const len = Math.round(code.length / 2);
            enc[0] = len | 0x80;
            if (Math.floor(code.length % 2) > 0) {
                code = "0" + code;
            }
            for (let i = 0; i < code.length; i = i + 2) {
                enc[1 + (i / 2)] = parseInt(code.substring(i, i + 2), 16);
            }
        }
        else {
            enc[0] = length;
        }
        return Buffer.from(enc);
    }
}
exports.EcUtils = EcUtils;
