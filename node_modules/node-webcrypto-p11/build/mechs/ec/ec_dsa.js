"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core = require("webcrypto-core");
const crypto_1 = require("./crypto");
const key_1 = require("./key");
class EcdsaProvider extends core.EcdsaProvider {
    constructor(crypto) {
        super();
        this.crypto = crypto;
        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.EcCrypto.generateKey(this.crypto.session, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    onSign(algorithm, key, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let buf = Buffer.from(data);
                const mechanism = this.wc2pk11(algorithm, algorithm);
                mechanism.name = crypto_1.EcCrypto.getAlgorithm(this.crypto.session, mechanism.name);
                if (mechanism.name === "ECDSA") {
                    buf = crypto_1.EcCrypto.prepareData(algorithm.hash.name, buf);
                }
                this.crypto.session.createSign(mechanism, key.key).once(buf, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(new Uint8Array(data2).buffer);
                    }
                });
            });
        });
    }
    onVerify(algorithm, key, signature, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let buf = Buffer.from(data);
                const mechanism = this.wc2pk11(algorithm, algorithm);
                mechanism.name = crypto_1.EcCrypto.getAlgorithm(this.crypto.session, mechanism.name);
                if (mechanism.name === "ECDSA") {
                    buf = crypto_1.EcCrypto.prepareData(algorithm.hash.name, buf);
                }
                this.crypto.session.createVerify(mechanism, key.key).once(buf, Buffer.from(signature), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2);
                    }
                });
            });
        });
    }
    onExportKey(format, key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return crypto_1.EcCrypto.exportKey(this.crypto.session, format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.EcCrypto.importKey(this.crypto.session, format, keyData, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof key_1.EcCryptoKey)) {
            throw new TypeError("key: Is not EC CryptoKey");
        }
    }
    wc2pk11(alg, keyAlg) {
        let algName;
        const hashAlg = alg.hash.name.toUpperCase();
        switch (hashAlg) {
            case "SHA-1":
                algName = "ECDSA_SHA1";
                break;
            case "SHA-224":
                algName = "ECDSA_SHA224";
                break;
            case "SHA-256":
                algName = "ECDSA_SHA256";
                break;
            case "SHA-384":
                algName = "ECDSA_SHA384";
                break;
            case "SHA-512":
                algName = "ECDSA_SHA512";
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${hashAlg}'`);
        }
        return { name: algName, params: null };
    }
}
exports.EcdsaProvider = EcdsaProvider;
