"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphene = require("graphene-pk11");
const core = require("webcrypto-core");
const crypto_1 = require("./crypto");
const key_1 = require("./key");
class EcdhProvider extends core.EcdhProvider {
    constructor(crypto) {
        super();
        this.crypto = crypto;
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.EcCrypto.generateKey(this.crypto.session, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    onExportKey(format, key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return crypto_1.EcCrypto.exportKey(this.crypto.session, format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.EcCrypto.importKey(this.crypto.session, format, keyData, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof key_1.EcCryptoKey)) {
            throw new TypeError("key: Is not EC CryptoKey");
        }
    }
    onDeriveBits(algorithm, baseKey, length) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let valueLen = 256;
                switch (baseKey.algorithm.namedCurve) {
                    case "P-256":
                    case "K-256":
                        valueLen = 256;
                        break;
                    case "P-384":
                        valueLen = 384;
                        break;
                    case "P-521":
                        valueLen = 534;
                        break;
                }
                const template = {
                    token: false,
                    sensitive: false,
                    class: graphene.ObjectClass.SECRET_KEY,
                    keyType: graphene.KeyType.GENERIC_SECRET,
                    extractable: true,
                    encrypt: true,
                    decrypt: true,
                    valueLen: valueLen >> 3,
                };
                const ecPoint = algorithm.public.key.getAttribute({ pointEC: null }).pointEC;
                this.crypto.session.deriveKey({
                    name: "ECDH1_DERIVE",
                    params: new graphene.EcdhParams(graphene.EcKdf.NULL, null, ecPoint),
                }, baseKey.key, template, (err, key) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        const secretKey = key.toType();
                        const value = secretKey.getAttribute({ value: null }).value;
                        resolve(new Uint8Array(value.slice(0, length >> 3)).buffer);
                    }
                });
            });
        });
    }
}
exports.EcdhProvider = EcdhProvider;
