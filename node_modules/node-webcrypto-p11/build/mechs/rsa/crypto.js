"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphene_pk11_1 = require("graphene-pk11");
const pvtsutils_1 = require("pvtsutils");
const core = require("webcrypto-core");
const utils = require("../../utils");
const key_1 = require("./key");
const asn1js = require("asn1js");
const { PrivateKeyInfo, PublicKeyInfo } = require("pkijs");
const HASH_PREFIXES = {
    "sha-1": Buffer.from([0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14]),
    "sha-256": Buffer.from([0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20]),
    "sha-384": Buffer.from([0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30]),
    "sha-512": Buffer.from([0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40]),
};
class RsaCrypto {
    static generateKey(session, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const size = algorithm.modulusLength;
            const exp = Buffer.from(algorithm.publicExponent);
            const template = this.createTemplate(session, algorithm, extractable, keyUsages);
            template.publicKey.publicExponent = exp;
            template.publicKey.modulusBits = size;
            return new Promise((resolve, reject) => {
                session.generateKeyPair(graphene_pk11_1.KeyGenMechanism.RSA, template.publicKey, template.privateKey, (err, keys) => {
                    try {
                        if (err) {
                            reject(new core.CryptoError(`Rsa: Can not generate new key\n${err.message}`));
                        }
                        else {
                            const wcKeyPair = {
                                privateKey: new key_1.RsaCryptoKey(keys.privateKey, algorithm),
                                publicKey: new key_1.RsaCryptoKey(keys.publicKey, algorithm),
                            };
                            resolve(wcKeyPair);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        });
    }
    static exportKey(session, format, key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (format.toLowerCase()) {
                case "jwk":
                    if (key.type === "private") {
                        return this.exportJwkPrivateKey(key);
                    }
                    else {
                        return this.exportJwkPublicKey(key);
                    }
                case "pkcs8": {
                    const jwk = yield this.exportJwkPrivateKey(key);
                    const privateKey = new PrivateKeyInfo();
                    privateKey.fromJSON(jwk);
                    return privateKey.toSchema(true).toBER(false);
                }
                case "spki": {
                    const jwk = yield this.exportJwkPublicKey(key);
                    const publicKey = new PublicKeyInfo();
                    publicKey.fromJSON(jwk);
                    return publicKey.toSchema(true).toBER(false);
                }
                case "raw": {
                    const jwk = yield this.exportJwkPublicKey(key);
                    const publicKey = new PublicKeyInfo();
                    publicKey.fromJSON(jwk);
                    return publicKey.toSchema(true).valueBlock.value[1].valueBlock.valueHex;
                }
                default:
                    throw new core.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
            }
        });
    }
    static importKey(session, format, keyData, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (format.toLowerCase()) {
                case "jwk":
                    const jwk = keyData;
                    if (jwk.d) {
                        return this.importJwkPrivateKey(session, jwk, algorithm, extractable, keyUsages);
                    }
                    else {
                        return this.importJwkPublicKey(session, jwk, algorithm, extractable, keyUsages);
                    }
                case "spki": {
                    const arBuf = new Uint8Array(keyData).buffer;
                    const asn1 = asn1js.fromBER(arBuf);
                    const jwk = new PublicKeyInfo({ schema: asn1.result }).toJSON();
                    return this.importJwkPublicKey(session, jwk, algorithm, extractable, keyUsages);
                }
                case "pkcs8": {
                    const arBuf = new Uint8Array(keyData).buffer;
                    const asn1 = asn1js.fromBER(arBuf);
                    const jwk = new PrivateKeyInfo({ schema: asn1.result }).toJSON();
                    return this.importJwkPrivateKey(session, jwk, algorithm, extractable, keyUsages);
                }
                default:
                    throw new core.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
            }
        });
    }
    static getAlgorithm(session, wcAlgorithmName, p11AlgorithmName) {
        const DEFAULT_RSA = wcAlgorithmName === "RSASSA-PKCS1-v1_5" ? "RSA_PKCS"
            : wcAlgorithmName === "RSA-PSS" ? "RSA_PKCS_PSS"
                : wcAlgorithmName === "RSA-OAEP" ? "RSA_PKCS_OAEP" : "RSA_PKCS";
        const mechanisms = session.slot.getMechanisms();
        let RSA;
        for (let i = 0; i < mechanisms.length; i++) {
            const mechanism = mechanisms.items(i);
            if (mechanism.name === p11AlgorithmName || mechanism.name === DEFAULT_RSA) {
                RSA = mechanism.name;
            }
        }
        if (!RSA) {
            throw new Error(`Cannot get PKCS11 RSA mechanism by name '${p11AlgorithmName}'`);
        }
        return RSA;
    }
    static prepareData(hashAlgorithm, data) {
        const hash = utils.digest(hashAlgorithm.replace("-", ""), data);
        const hashPrefix = HASH_PREFIXES[hashAlgorithm.toLowerCase()];
        if (!hashPrefix) {
            throw new Error(`Cannot get prefix for hash '${hashAlgorithm}'`);
        }
        return Buffer.concat([hashPrefix, hash]);
    }
    static jwkAlgName(algorithm) {
        switch (algorithm.name.toUpperCase()) {
            case "RSA-OAEP":
                const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
                return `RSA-OAEP${mdSize !== "1" ? `-${mdSize}` : ""}`;
            case "RSASSA-PKCS1-V1_5":
                return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
            case "RSA-PSS":
                return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
            default:
                throw new core.OperationError("algorithm: Is not recognized");
        }
    }
    static exportJwkPublicKey(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pkey = key.key.getAttribute({
                publicExponent: null,
                modulus: null,
            });
            const alg = this.jwkAlgName(key.algorithm);
            const jwk = {
                kty: "RSA",
                alg,
                ext: true,
                key_ops: key.usages,
                e: pvtsutils_1.Convert.ToBase64Url(pkey.publicExponent),
                n: pvtsutils_1.Convert.ToBase64Url(pkey.modulus),
            };
            return jwk;
        });
    }
    static exportJwkPrivateKey(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pkey = key.key.getAttribute({
                publicExponent: null,
                modulus: null,
                privateExponent: null,
                prime1: null,
                prime2: null,
                exp1: null,
                exp2: null,
                coefficient: null,
            });
            const alg = this.jwkAlgName(key.algorithm);
            const jwk = {
                kty: "RSA",
                alg,
                ext: true,
                key_ops: key.usages,
                e: pvtsutils_1.Convert.ToBase64Url(pkey.publicExponent),
                n: pvtsutils_1.Convert.ToBase64Url(pkey.modulus),
                d: pvtsutils_1.Convert.ToBase64Url(pkey.privateExponent),
                p: pvtsutils_1.Convert.ToBase64Url(pkey.prime1),
                q: pvtsutils_1.Convert.ToBase64Url(pkey.prime2),
                dp: pvtsutils_1.Convert.ToBase64Url(pkey.exp1),
                dq: pvtsutils_1.Convert.ToBase64Url(pkey.exp2),
                qi: pvtsutils_1.Convert.ToBase64Url(pkey.coefficient),
            };
            return jwk;
        });
    }
    static importJwkPrivateKey(session, jwk, algorithm, extractable, keyUsages) {
        const template = this.createTemplate(session, algorithm, extractable, keyUsages).privateKey;
        template.publicExponent = utils.b64UrlDecode(jwk.e);
        template.modulus = utils.b64UrlDecode(jwk.n);
        template.privateExponent = utils.b64UrlDecode(jwk.d);
        template.prime1 = utils.b64UrlDecode(jwk.p);
        template.prime2 = utils.b64UrlDecode(jwk.q);
        template.exp1 = utils.b64UrlDecode(jwk.dp);
        template.exp2 = utils.b64UrlDecode(jwk.dq);
        template.coefficient = utils.b64UrlDecode(jwk.qi);
        const p11key = session.create(template).toType();
        return new key_1.RsaCryptoKey(p11key, algorithm);
    }
    static importJwkPublicKey(session, jwk, algorithm, extractable, keyUsages) {
        const template = this.createTemplate(session, algorithm, extractable, keyUsages).publicKey;
        template.publicExponent = utils.b64UrlDecode(jwk.e);
        template.modulus = utils.b64UrlDecode(jwk.n);
        const p11key = session.create(template).toType();
        return new key_1.RsaCryptoKey(p11key, algorithm);
    }
    static createTemplate(session, alg, extractable, keyUsages) {
        const label = `RSA-${alg.modulusLength}`;
        const idKey = utils.GUID(session);
        return {
            privateKey: {
                token: !!process.env.WEBCRYPTO_PKCS11_TOKEN,
                sensitive: !!process.env.WEBCRYPTO_PKCS11_SENSITIVE,
                class: graphene_pk11_1.ObjectClass.PRIVATE_KEY,
                keyType: graphene_pk11_1.KeyType.RSA,
                private: true,
                label,
                id: idKey,
                extractable,
                derive: false,
                sign: keyUsages.indexOf("sign") > -1,
                decrypt: keyUsages.indexOf("decrypt") > -1,
                unwrap: keyUsages.indexOf("unwrapKey") > -1,
            },
            publicKey: {
                token: !!process.env.WEBCRYPTO_PKCS11_TOKEN,
                class: graphene_pk11_1.ObjectClass.PUBLIC_KEY,
                keyType: graphene_pk11_1.KeyType.RSA,
                private: false,
                label,
                id: idKey,
                verify: keyUsages.indexOf("verify") > -1,
                encrypt: keyUsages.indexOf("encrypt") > -1,
                wrap: keyUsages.indexOf("wrapKey") > -1,
            },
        };
    }
}
RsaCrypto.publicKeyUsages = ["verify", "encrypt", "wrapKey"];
RsaCrypto.privateKeyUsages = ["sign", "decrypt", "unwrapKey"];
exports.RsaCrypto = RsaCrypto;
