"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphene = require("graphene-pk11");
const core = require("webcrypto-core");
const crypto_1 = require("./crypto");
const key_1 = require("./key");
class RsaPssProvider extends core.RsaPssProvider {
    constructor(crypto) {
        super();
        this.crypto = crypto;
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.RsaCrypto.generateKey(this.crypto.session, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    onSign(algorithm, key, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let buf = Buffer.from(data);
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                mechanism.name = crypto_1.RsaCrypto.getAlgorithm(this.crypto.session, this.name, mechanism.name);
                if (mechanism.name === "RSA_PKCS_PSS") {
                    buf = crypto_1.RsaCrypto.prepareData(key.algorithm.hash.name, buf);
                }
                this.crypto.session.createSign(mechanism, key.key).once(buf, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(new Uint8Array(data2).buffer);
                    }
                });
            });
        });
    }
    onVerify(algorithm, key, signature, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let buf = Buffer.from(data);
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                mechanism.name = crypto_1.RsaCrypto.getAlgorithm(this.crypto.session, this.name, mechanism.name);
                if (mechanism.name === "RSA_PKCS_PSS") {
                    buf = crypto_1.RsaCrypto.prepareData(key.algorithm.hash.name, buf);
                }
                this.crypto.session.createVerify(mechanism, key.key).once(buf, Buffer.from(signature), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2);
                    }
                });
            });
        });
    }
    onExportKey(format, key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return crypto_1.RsaCrypto.exportKey(this.crypto.session, format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.RsaCrypto.importKey(this.crypto.session, format, keyData, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof key_1.RsaCryptoKey)) {
            throw new TypeError("key: Is not PKCS11 CryptoKey");
        }
    }
    wc2pk11(alg, keyAlg) {
        let mech;
        let param;
        const saltLen = alg.saltLength;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                mech = "SHA1_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA1, graphene.RsaMgf.MGF1_SHA1, saltLen);
                break;
            case "SHA-224":
                mech = "SHA224_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA224, graphene.RsaMgf.MGF1_SHA224, saltLen);
                break;
            case "SHA-256":
                mech = "SHA256_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA256, graphene.RsaMgf.MGF1_SHA256, saltLen);
                break;
            case "SHA-384":
                mech = "SHA384_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA384, graphene.RsaMgf.MGF1_SHA384, saltLen);
                break;
            case "SHA-512":
                mech = "SHA512_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA512, graphene.RsaMgf.MGF1_SHA512, saltLen);
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${keyAlg.hash.name}'`);
        }
        return { name: mech, params: param };
    }
}
exports.RsaPssProvider = RsaPssProvider;
