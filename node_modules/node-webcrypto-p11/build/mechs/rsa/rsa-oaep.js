"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphene = require("graphene-pk11");
const core = require("webcrypto-core");
const crypto_1 = require("./crypto");
const key_1 = require("./key");
class RsaOaepProvider extends core.RsaOaepProvider {
    constructor(crypto) {
        super();
        this.crypto = crypto;
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.RsaCrypto.generateKey(this.crypto.session, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    onEncrypt(algorithm, key, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const buf = Buffer.from(data);
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                const context = Buffer.alloc(key.algorithm.modulusLength >> 3);
                this.crypto.session.createCipher(mechanism, key.key)
                    .once(buf, context, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(new Uint8Array(data2).buffer);
                    }
                });
            });
        });
    }
    onDecrypt(algorithm, key, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const buf = Buffer.from(data);
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                const context = Buffer.alloc(key.algorithm.modulusLength >> 3);
                this.crypto.session.createDecipher(mechanism, key.key)
                    .once(buf, context, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(new Uint8Array(data2).buffer);
                    }
                });
            });
        });
    }
    onExportKey(format, key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return crypto_1.RsaCrypto.exportKey(this.crypto.session, format, key);
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = yield crypto_1.RsaCrypto.importKey(this.crypto.session, format, keyData, Object.assign({}, algorithm, { name: this.name }), extractable, keyUsages);
            return key;
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof key_1.RsaCryptoKey)) {
            throw new TypeError("key: Is not PKCS11 CryptoKey");
        }
    }
    wc2pk11(alg, keyAlg) {
        let params;
        const sourceData = alg.label ? Buffer.from(alg.label) : undefined;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA1, graphene.RsaMgf.MGF1_SHA1, sourceData);
                break;
            case "SHA-224":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA224, graphene.RsaMgf.MGF1_SHA224, sourceData);
                break;
            case "SHA-256":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA256, graphene.RsaMgf.MGF1_SHA256, sourceData);
                break;
            case "SHA-384":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA384, graphene.RsaMgf.MGF1_SHA384, sourceData);
                break;
            case "SHA-512":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA512, graphene.RsaMgf.MGF1_SHA512, sourceData);
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${keyAlg.hash.name}'`);
        }
        const res = { name: "RSA_PKCS_OAEP", params };
        return res;
    }
}
exports.RsaOaepProvider = RsaOaepProvider;
