"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphene = require("graphene-pk11");
const pvtsutils_1 = require("pvtsutils");
const core = require("webcrypto-core");
const utils = require("../../utils");
const key_1 = require("./key");
class HmacProvider extends core.HmacProvider {
    constructor(crypto) {
        super();
        this.crypto = crypto;
    }
    onGenerateKey(algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                algorithm.length = algorithm.length
                    ? algorithm.length
                    : this.getDefaultLength(algorithm.hash.name) >> 3;
                const template = this.createTemplate(algorithm, extractable, keyUsages);
                template.valueLen = algorithm.length << 3;
                this.crypto.session.generateKey(graphene.KeyGenMechanism.GENERIC_SECRET, template, (err, aesKey) => {
                    try {
                        if (err) {
                            reject(new core.CryptoError(`HMAC: Cannot generate new key\n${err.message}`));
                        }
                        else {
                            resolve(new key_1.HmacCryptoKey(aesKey, Object.assign({}, algorithm, { name: this.name })));
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        });
    }
    onSign(algorithm, key, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                this.crypto.session.createSign(mechanism, key.key).once(Buffer.from(data), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(new Uint8Array(data2).buffer);
                    }
                });
            });
        });
    }
    onVerify(algorithm, key, signature, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                this.crypto.session.createVerify(mechanism, key.key).once(Buffer.from(data), Buffer.from(signature), (err, ok) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(ok);
                    }
                });
            });
        });
    }
    onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let value;
            switch (format.toLowerCase()) {
                case "jwk":
                    if (!("k" in keyData)) {
                        throw new core.OperationError("jwk.k: Cannot get required property");
                    }
                    keyData = pvtsutils_1.Convert.FromBase64Url(keyData.k);
                case "raw":
                    value = keyData;
                    break;
                default:
                    throw new core.OperationError("format: Must be 'jwk' or 'raw'");
            }
            const hmacAlg = Object.assign({}, algorithm, { name: this.name, length: value.byteLength * 8 || this.getDefaultLength(algorithm.hash.name) });
            const template = this.createTemplate(hmacAlg, extractable, keyUsages);
            template.value = Buffer.from(value);
            const sessionObject = this.crypto.session.create(template);
            const key = new key_1.HmacCryptoKey(sessionObject.toType(), hmacAlg);
            return key;
        });
    }
    onExportKey(format, key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const template = key.key.getAttribute({ value: null });
            switch (format.toLowerCase()) {
                case "jwk":
                    const jwk = {
                        kty: "oct",
                        k: pvtsutils_1.Convert.ToBase64Url(template.value),
                        alg: `HS${key.algorithm.hash.name.replace("SHA-", "")}`,
                        ext: true,
                        key_ops: key.usages,
                    };
                    return jwk;
                case "raw":
                    return new Uint8Array(template.value).buffer;
                    break;
                default:
                    throw new core.OperationError("format: Must be 'jwk' or 'raw'");
            }
        });
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof key_1.HmacCryptoKey)) {
            throw new TypeError("key: Is not HMAC CryptoKey");
        }
    }
    createTemplate(alg, extractable, keyUsages) {
        const id = utils.GUID(this.crypto.session);
        return {
            token: !!process.env.WEBCRYPTO_PKCS11_TOKEN,
            sensitive: !!process.env.WEBCRYPTO_PKCS11_SENSITIVE,
            class: graphene.ObjectClass.SECRET_KEY,
            keyType: graphene.KeyType.GENERIC_SECRET,
            label: `HMAC-${alg.length << 3}`,
            id,
            extractable,
            derive: false,
            sign: keyUsages.indexOf("sign") !== -1,
            verify: keyUsages.indexOf("verify") !== -1,
            encrypt: keyUsages.indexOf("encrypt") !== -1 || keyUsages.indexOf("wrapKey") !== -1,
            decrypt: keyUsages.indexOf("decrypt") !== -1 || keyUsages.indexOf("unwrapKey") !== -1,
            wrap: keyUsages.indexOf("wrapKey") !== -1,
            unwrap: keyUsages.indexOf("unwrapKey") !== -1,
        };
    }
    wc2pk11(alg, keyAlg) {
        let res;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                res = "SHA_1_HMAC";
                break;
            case "SHA-224":
                res = "SHA224_HMAC";
                break;
            case "SHA-256":
                res = "SHA256_HMAC";
                break;
            case "SHA-384":
                res = "SHA384_HMAC";
                break;
            case "SHA-512":
                res = "SHA512_HMAC";
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${keyAlg.hash.name}'`);
        }
        return { name: res, params: null };
    }
}
exports.HmacProvider = HmacProvider;
